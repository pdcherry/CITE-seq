---
title: "CITE-seq analysis proof-of-concept"
author: "Patrick Cherry"
date: "June 20, 2024"
mainfont: Helvetica Neue
format:
  pdf:
    df-print: kable
    toc: FALSE
    toc-depth: 2
    fontsize: "8"
    fig-align: center
    fig-height: 2.5
    geometry:
    - top = 10mm
    - bottom = 20mm
    - left = 15mm
    - right = 15mm
  gfm:
    toc: TRUE
    toc-depth: 2
    output-file: "README.md"
execute:
  freeze: true
---
```{r setup, echo = FALSE, message = FALSE}
knitr::opts_chunk$set(echo = FALSE)
library(tidyverse, quietly = TRUE)
library(patchwork)
library(fs)
library(here)
library(Seurat)
library(Matrix)
library(testthat)
theme_set(theme_light())
out_path <- path(here(), Sys.Date())
file_prefix <- "CITE-seq"
data_dir <- path(here(), "data", "GSE100866")
```
```{r}
fs::dir_ls(data_dir) |> fs::path_file()
```

```{r}
path(out_path, file_prefix)
```

## Intro
CITE-seq using data from Stoeckius, et al (Nat Methods 14, 865â€“868 (2017) 10.1038/nmeth.4380) in GSE100866

Seurat multi-modal clustering

<!-- https://cran.r-project.org/web/packages/dsb/vignettes/end_to_end_workflow.html -->
<!-- https://broadinstitute.github.io/2020_scWorkshop/cite-seq.html -->

### Methods Intro
From [Supplementary Figure 1 CITE-seq library preparation](https://www.nature.com/articles/nmeth.4380#Sec18):

 > Illustration of the DNA-barcoded antibodies used in CITE-seq. (b) Antibody-oligonucleotide complexes appear as a high-molecular-weight smear when run on an agarose gel (1). Cleavage of the oligo from the antibody by reduction of the disulfide bond collapses the smear to oligo length (2). (c) Drop-seq beads are microparticles with conjugated oligonucleotides comprising a common PCR handle, a cell barcode, followed by a unique molecular identifier (UMI) and a polyT tail. (d) Schematic illustration of CITE-seq library prep in Drop-seq (downstream of Fig. 1b). Reverse transcription and template switch is performed in bulk after emulsion breakage. After amplification, full length cDNA and antibody-oligo products can be separated by size and amplified independently (also shown in d) (e) Reverse transcription and amplification produces two product populations with distinct sizes (left panel). These can be size separated and amplified independently to obtain full length cDNAs (top panel, capillary electrophoresis trace) and ADTs (bottom panel, capillary electrophoresis trace).
 
## Read in data
### count data
```{r}
cbmc_rna <-
  as.sparse(
    read.csv(
      path(data_dir, "GSE100866_CBMC_8K_13AB_10X-RNA_umi.csv.gz"),
      sep = ",", header = TRUE, row.names = 1))
```
```{r}
dim(cbmc_rna)
```

`dim()` outputs (columns, rows); the CBMC matrix (cord blood mononuclear cells) contains 36280 features and 8617 samples (single cell droplets).

```{r}
cbmc_rna <- CollapseSpeciesExpressionMatrix(cbmc_rna,
                                            prefix = "HUMAN_", controls = "MOUSE_",
                                            ncontrols = 100)
```
```{r}
dim(cbmc_rna)
```
 
`CollapseSpeciesExpressionMatrix()` is a convenience function for slimming down a multi-species expression matrix, when only one species is primarily of interest. Given the default parameter of `ncontrols = 100`, this command keeps only the top 100 features detected from each species in each sample. This matrix went from 36280 to 20501 features, which is a 43% reduction.

### ADT UMI matrix
```{r}
cbmc_adt <-
  as.sparse(
    read.csv(
      path(data_dir, "GSE100866_CBMC_8K_13AB_10X-ADT_umi.csv.gz"),
      sep = ",", header = TRUE, row.names = 1))
```
```{r}
dim(cbmc_adt)
```

#### Quick matrix QC
```{r test UMI counts of rna and adt matrices}
testthat::expect_equal(dim(cbmc_rna)[2] == dim(cbmc_adt)[2],
                       TRUE)
```

The number of rows (samples / UMIs) matches the RNA counts matrix; we have corresponding sample data.

```{r}
length(intersect(colnames(cbmc_rna), colnames(cbmc_adt))) /
  length(union(colnames(cbmc_rna), colnames(cbmc_adt)))
```

And the names of the samples all match.

## Seurat object & cluster
```{r}
cbmc <- CreateSeuratObject(counts = cbmc_rna)
```
```{r}
cbmc <- NormalizeData(cbmc)
```
```{r}
cbmc <- FindVariableFeatures(cbmc)
```
```{r}
cbmc <- ScaleData(cbmc)
```

```{r}
cbmc <- RunPCA(cbmc, verbose = FALSE)
ElbowPlot(cbmc, ndims = 50)
```

```{r}
cbmc <- FindNeighbors(cbmc, dims = 1:25)
cbmc <- FindClusters(cbmc, resolution = 0.8)
```
```{r}
cbmc <- RunTSNE(cbmc, dims = 1:25, method = "FIt-SNE")
```
```{r message = FALSE}
cbmc_rna_markers <-
  FindAllMarkers(cbmc,
                 max.cells.per.ident = 100, logfc.threshold = log(2),
                 only.pos = TRUE, min.diff.pct = 0.3, verbose = FALSE)
```

### Clustering t-SNE plot
```{r}
#new.cluster.ids <- c("Memory CD4 T", "CD14+ Mono", "Naive CD4 T", "NK", "CD14+ Mono",
#                     "Mouse", "B", "CD8 T", "CD16+ Mono", "T/Mono doublets", "NK", "CD34+",
#                     "Multiplets", "Mouse", "Eryth", "Mk", "Mouse", "DC", "pDCs")
#names(new.cluster.ids) <- levels(cbmc)
#cbmc <- RenameIdents(cbmc, new.cluster.ids)

DimPlot(cbmc, label = TRUE, reduction = "tsne")# + NoLegend()
```

## Incorporate protein expression (antibody barcodes) to the Seurat object
```{r}
cbmc[["ADT"]] <- CreateAssayObject(counts = cbmc_adt)
```

The above code adds a new assay called "ADT" to the Seurat object `cmbc`. We can confirm it's added with the following `GetAssayData()` command.

```{r}
GetAssayData(cbmc, layer = "counts", assay = "ADT")[1:3,1:3]
```
```{r}
rownames(cbmc_adt)
```

Now we can repeat the pre-processing (normalization and scaling) steps that we typically run with RNA, but modifying the 'assay' argument.

(For CITE-seq data, the Broad does not recommend typical LogNormalization. Instead, they use a centered log-ratio (CLR) normalization, computed independently for each feature. This is a slightly improved procedure from the original publication.)

```{r}
cbmc <- NormalizeData(cbmc, assay = "ADT", normalization.method = "CLR")
```
```{r}
cbmc <- ScaleData(cbmc, assay = "ADT")
```

```{r}
DefaultAssay(cbmc) <- "RNA"
```

```{r}
FeaturePlot(cbmc, features = c("adt_CD3", "adt_CD11c", "adt_CD8",
                               "adt_CD16", "CD3E", "ITGAX", "CD8A", "FCGR3A"),
            min.cutoff = "q05", max.cutoff = "q95", ncol = 4)
```

